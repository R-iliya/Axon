# ðŸ§  Axon Parser â€” Full Documentation

> **Module:** `axon/parser.py`
> **Purpose:** Translates tokenized Axon source code into an Abstract Syntax Tree (AST).
> **Depends on:**
>
> * `axon.lexer` â†’ for tokenization
> * `axon.nodes` â†’ for AST node definitions

---

## Overview

The **Axon Parser** is the brain of the language â€” it takes raw tokens generated by the **Lexer** and builds a structured, hierarchical **Abstract Syntax Tree (AST)** that represents the logical structure of your program.

This parser supports:

* Expressions (`+`, `-`, `*`, `/`, `==`, etc.)
* Control structures (`if`, `else`, `while`, `for`)
* Variable declarations (`let`)
* Functions (`fn`, `return`)
* Data structures (`list`, `dict`, indexing)
* Built-ins like `print`, `cls`, and loop control (`break`, `continue`)

If you imagine the **Lexer** as reading the code, the **Parser** is *understanding* it.

---

## Architecture

```text
 Source Code
     â†“
   Lexer â†’ Tokens
     â†“
  Parser â†’ Abstract Syntax Tree (AST)
     â†“
  Interpreter â†’ Execution
```

Each token is consumed and transformed into an instance of an appropriate **Node** class (from `axon.nodes`).
For example, `print(5+3);` â†’ becomes a `PrintNode` containing a `BinOpNode` of two `NumberNode`s.

---

## Core Components

### ### 1 `Parser` Class

The heart of the parser.
It walks through the token stream and constructs AST nodes according to Axonâ€™s grammar.

#### Initialization

```python
parser = Parser(code)
```

* Tokenizes the input source using `tokenize()`
* Sets the current parsing position to `0`

---

### ### 2 `ParseError`

A simple custom exception used to flag syntax or grammar issues:

```python
class ParseError(Exception):
    pass
```

Itâ€™s raised whenever something unexpected happens â€” like a missing parenthesis, colon, or malformed expression.

---

## Expression Parsing

Expression parsing follows a **recursive-descent** pattern with clear precedence levels.
From lowest to highest precedence:

| Level | Function           | Operators                                           |
| ----- | ------------------ | --------------------------------------------------- |
| 1     | `parse_expression` | `or`                                                |
| 2     | `parse_logic_term` | `and`                                               |
| 3     | `parse_comparison` | `==`, `!=`, `<`, `>`, `<=`, `>=`                    |
| 4     | `parse_term`       | `+`, `-`                                            |
| 5     | `parse_factor`     | Literals, variables, calls, lists, dicts, unary ops |

---

### `parse_expression(stop_tokens=None)`

Handles logical ORs:

```axon
if true or false { ... }
```

**Returns:** a `BinOpNode(left, 'or', right)`

---

### `parse_logic_term(stop_tokens=None)`

Handles logical ANDs:

```axon
while a and b { ... }
```

---

### `parse_comparison(stop_tokens=None)`

Handles comparison operators:

```axon
a < b
x == y
value != 10
```

---

### `parse_term(stop_tokens=None)`

Adds and subtracts:

```axon
1 + 2 - 3
```

**Node:** `BinOpNode(left, '+', right)` or `BinOpNode(left, '-', right)`

---

### `parse_factor(stop_tokens=None)`

Handles the most granular units:

* **Literals:** numbers, strings, booleans
* **Unary ops:** `-x`, `not y`
* **Variables**
* **Parenthesized expressions:** `(a + b)`
* **Lists:** `[1, 2, 3]`
* **Dicts:** `{key: value, ...}`
* **Indexing:** `arr[0]`
* **Function calls:** `foo(1, "bar")`

#### Example

```axon
let arr = [1, 2, 3];
print(arr[1]);
```

Results in:

```
LetNode(
  var_name="arr",
  expr=ListNode([NumberNode(1), NumberNode(2), NumberNode(3)])
)

PrintNode(
  expr=IndexNode(
    VariableNode("arr"),
    NumberNode(1)
  )
)
```

---

## Statement Parsing

Every Axon statement ends with a **semicolon (`;`)** â€” except control blocks (`if`, `for`, etc.) which use `{}`.
`parse_statement()` decides which node type to create based on the leading keyword.

---

### ### ðŸ”¹ `print` Statement

```axon
print("Hello World");
```

â†’ `PrintNode(StringNode("Hello World"))`

---

### ### ðŸ”¹ Variable Declaration

```axon
let x = 5;
```

â†’ `LetNode("x", NumberNode(5))`

---

### ### ðŸ”¹ Clear Screen

```axon
cls;
```

â†’ `ClearNode()`

---

### ### ðŸ”¹ Control Flow

#### **If / Else**

```axon
if x > 5 {
  print("big");
} else {
  print("small");
}
```

â†’ `IfNode(condition, true_body, false_body)`

#### **While Loop**

```axon
while count < 10 {
  print(count);
  count = count + 1;
}
```

â†’ `WhileNode(condition, body)`

#### **For Loop**

```axon
for i = 0 to 5 {
  print(i);
}
```

â†’ `ForNode(var_name, start_expr, end_expr, body)`

---

### ### ðŸ”¹ Functions

#### **Declaration**

```axon
fn greet(name) {
  print("Hello, " + name);
}
```

â†’ `FunctionNode(name="greet", params=["name"], body=[...])`

#### **Return**

```axon
return 42;
```

â†’ `ReturnNode(NumberNode(42))`

#### **Call**

```axon
greet("Axon");
```

â†’ `CallNode("greet", [StringNode("Axon")])`

---

### ### ðŸ”¹ Loop Controls

```axon
break;
continue;
```

â†’ `BreakNode()` and `ContinueNode()`

---

### ### ðŸ”¹ Inline Assignments

```axon
x = 10;
```

Even without `let`, Axon supports simple reassignments.

â†’ `LetNode("x", NumberNode(10))`

---

## Parsing Blocks

Multi-line control blocks (`{ ... }`) are parsed by `parse_block()`,
which simply reads multiple statements until it encounters the matching closing brace.

---

## Putting It All Together

### âœ… Example Program

```axon
let total = 0;
for i = 0 to 5 {
    total = total + i;
}
print(total);
```

### AST Output (conceptually)

```
[
  LetNode("total", NumberNode(0)),
  ForNode(
    var_name="i",
    start_expr=NumberNode(0),
    end_expr=NumberNode(5),
    body=[
      LetNode("total",
        BinOpNode(VariableNode("total"), "+", VariableNode("i"))
      )
    ]
  ),
  PrintNode(VariableNode("total"))
]
```

---

## Utility Function â€” `parse_text()`

```python
def parse_text(code):
    parser = Parser(code)
    return parser.parse()
```

This acts as the **public entry point** for any module that needs to parse Axon code (like the interpreter or REPL).

---

## âš¡ Example Usage

```python
from axon.parser import parse_text

program = """
let x = 2;
let y = x * 5;
print(y);
"""

ast = parse_text(program)
print(ast)
```

Output:

```
[
  LetNode("x", NumberNode(2)),
  LetNode("y", BinOpNode(VariableNode("x"), "*", NumberNode(5))),
  PrintNode(VariableNode("y"))
]
```

---

## Error Handling

Whenever a syntactic mismatch occurs, a `ParseError` is raised:

```python
raise ParseError("Expected ')' after function call")
```

This ensures clear feedback when parsing invalid or incomplete Axon code.

---

## Design Principles

* **Recursive Descent:** readable, modular, easily extendable grammar.
* **AST-Driven:** everything is a node; statements and expressions use the same unified structure.
* **Human-Readable Errors:** clear, line-friendly exceptions.
* **Language-Agnostic Nodes:** so later interpreter or compiler stages can reuse them.

---

## Extending the Parser

Adding a new keyword or structure?
Just follow these steps:

1. Add a new **Node** class in `axon/nodes.py`.
2. Modify `parse_statement()` to recognize your new keyword.
3. Optionally extend `parse_expression()` if it introduces a new operator.

Example: adding a `repeat` loop

```python
elif token.value == 'repeat':
    self.advance()
    count_expr = self.parse_expression(stop_tokens=['LBRACE'])
    self.advance()
    body = self.parse_block()
    return RepeatNode(count_expr, body)
```

---

## ðŸ§  Summary

| Component            | Purpose                                     |
| -------------------- | ------------------------------------------- |
| `Parser`             | Core class that converts tokens into an AST |
| `parse_expression()` | Parses logic and math expressions           |
| `parse_statement()`  | Parses control flow and declarations        |
| `parse_text()`       | Public API for parsing code                 |
| `ParseError`         | Signals syntax errors                       |

---

## ðŸ§¾ License

This parser is part of the **Axon Language Project**.
Feel free to modify or expand for your own language experiments.

---

Would you like me to add **syntax-highlighted code snippets** and **diagram illustrations (AST + flow)** for a fancier GitHub README look? I can format it with visuals and emoji headers to make it stand out like a real dev-tool project.
